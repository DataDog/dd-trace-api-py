import os

import yaml

INITPATH = os.path.join(os.path.dirname(__file__), "dd_trace_api", "__init__.py")
with open(os.path.join(os.path.dirname(__file__), "api.yaml")) as definition_stream:
    definition = yaml.safe_load(definition_stream)


def _generate_module(module_name, module_info):
    """Generate a stub that is not intended to be instantiated in client code"""
    attrs_code = "\n".join(
        [
            f"""
setattr({module_name}, "{attribute_name}", {attribute_name})
    """
            for attribute_name, attribute_value in module_info.get("attributes", {}).items()
        ]
    )
    code = f"""
{module_name} = {module_info.get("instance_of", "_Stub")}()
{attrs_code}
    """
    _write_out(code)


def _build_method_params_and_hook_args(class_name, method_name, method_info):
    is_static = method_info.get("static", False)
    posarg_defs, kwarg_defs, args, kwargs = [], [], [], []
    for arg, info in method_info.get("posargs", {}).items():
        posarg_defs.append(f"{arg}: {info['type']}")
        args.append(arg)
    for kwarg, info in method_info.get("kwargs", {}).items():
        kwarg_defs.append(f"{kwarg}:{info.get('type')}={info.get('default').__repr__()}")
        kwargs.append(kwarg)
    kwargs_str = "{" + ", ".join([f"'{kwarg}': {kwarg}" for kwarg in kwargs]) + "}"
    self_param = ["self"] if not is_static else []
    params = ", ".join(self_param + posarg_defs + kwarg_defs)
    args = ["retval", "self", f"'{method_name}'"] + args
    args_str = "[" + ", ".join(args) + "]"
    all_hook_args = f"{args_str}, {kwargs_str}"
    return params, all_hook_args


def _build_impl_retval(method_info):
    impl_retval_code = ""
    if method_info.get("uses_impl_retval", False):
        impl_retval_code = "shared_state['impl_return_value'] = None"
    return impl_retval_code


def _build_method(class_name, class_info, method_name, method_info):
    if method_info.get("written", False):
        return _connect_written_method(class_name, class_info, method_name, method_info)
    else:
        return _build_method_from_yaml(class_name, class_info, method_name, method_info)


def _connect_written_method(class_name, class_info, method_name, method_info):
    return f"""
    {method_name} = written._{class_name}_{method_name}
    """


def _build_method_from_yaml(class_name, class_info, method_name, method_info):
    return_info = method_info.get("return_info", {})
    params, all_hook_args = _build_method_params_and_hook_args(class_name, method_name, method_info)
    return f"""
    {"@staticmethod" if method_info.get("static", False) else ""}
    def {method_name}({params}) -> {return_info.get('type')}:
        '''
        {method_info.get("docstring", '')}
        '''
        retval = {return_info.get('value')}
        {_build_impl_retval(method_info)}
        # XXX no string concatenation
        audit(_DD_HOOK_NAME, ({all_hook_args}))
        return retval
    """


def _generate_class(class_name, class_info):
    method_lines = []
    for method_name, method_info in class_info.get("methods", {}).items():
        method_lines.append(_build_method(class_name, class_info, method_name, method_info))
    methods_code = "".join(method_lines)
    code = f"""
class {class_name}():
{methods_code or "pass"}
    """
    _write_out(code)


def _write_out(text: str):
    with open(INITPATH, "a+") as f:
        f.write(text + "\n")


def _iterate_node_members(node):
    for member_info in node.get("attributes", node.get("methods", {})).items():
        yield member_info


def _build_classes(node):
    modules_to_generate = []
    for member_name, member_data in _iterate_node_members(node):
        if "methods" in member_data:
            _generate_class(member_name, member_data)
        if "attributes" in member_data:
            _build_classes(member_data)
            modules_to_generate.append((member_name, member_data))
        if "instance_of" in member_data:
            modules_to_generate.append((member_name, member_data))
    # this has to happen in a second pass because some of the modules reference generated classes
    for member_name, member_data in modules_to_generate:
        _generate_module(member_name, member_data)


def _generate_header():
    code = """
# This file was generated by generate.py. Do not modify directly.
import functools
from sys import audit
from types import TracebackType  # noqa:F401
from typing import Optional, Any, Callable, Dict, List, Union, Text, Tuple, TypeVar, Type  # noqa:F401
import importlib.metadata
__version__ = importlib.metadata.version('dd_trace_api')

from .constants import _DD_HOOK_NAME
from . import written


class _Stub:
    pass
    """
    _write_out(code)


def _generate_api(node):
    if os.path.isfile(INITPATH):
        os.remove(INITPATH)
    _generate_header()
    _build_classes(node)


_generate_api(definition)
