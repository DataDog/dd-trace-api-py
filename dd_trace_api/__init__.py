
# This file was generated by generate.py. Do not modify directly.
import functools
from sys import audit
from types import TracebackType  # noqa:F401
from typing import Optional, Any, Callable, Dict, List, Union, Text, Tuple, TypeVar, Type  # noqa:F401
import importlib.metadata
__version__ = importlib.metadata.version('dd_trace_api')

_DD_HOOK_PREFIX = "dd.hooks."


class _Stub:
    pass
    

class Span():
    
    
    def __enter__(self) -> 'Span':
        ''''''
        
        retval = self
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Span.__enter__", ([shared_state], {}))
        return shared_state.get("impl_return_value", retval)
        
    
    def __exit__(self, exc_type: Type[BaseException], exc_val: BaseException, exc_tb: Optional[TracebackType]) -> None:
        ''''''
        
        retval = None
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Span.__exit__", ([shared_state, exc_type, exc_val, exc_tb], {}))
        return shared_state.get("impl_return_value", retval)
        
    
    def set_exc_info(self, exc_type: Type[BaseException], exc_val: BaseException, exc_tb: Optional[TracebackType]) -> None:
        '''Tag the span with an error tuple as from ``sys.exc_info()``'''
        
        retval = None
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Span.set_exc_info", ([shared_state, exc_type, exc_val, exc_tb], {}))
        return shared_state.get("impl_return_value", retval)
        
    
    def set_traceback(self, limit:Optional[int]=None) -> None:
        '''"If the current stack has an exception, tag the span with the relevant error info. If not, tag
it with the current python stack."
'''
        
        retval = None
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Span.set_traceback", ([shared_state], {'limit': limit}))
        return shared_state.get("impl_return_value", retval)
        
    
    def set_tags(self, tags: Dict[Union[Text, bytes], Any]) -> None:
        '''Set a dictionary of tags on the given span. Keys and values must be strings (or stringable)'''
        
        retval = None
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Span.set_tags", ([shared_state, tags], {}))
        return shared_state.get("impl_return_value", retval)
        
    
    def finish_with_ancestors(self) -> None:
        '''"
Finish this span along with all (accessible) ancestors of this span.

This method is useful if a sudden program shutdown is required and finishing
the trace is desired.
"
'''
        
        retval = None
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Span.finish_with_ancestors", ([shared_state], {}))
        return shared_state.get("impl_return_value", retval)
        
    
    def finish(self, finish_time:Optional[float]=None) -> None:
        '''"Mark the end time of the span and submit it to the tracer.
If the span has already been finished don't do anything.
"
'''
        
        retval = None
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Span.finish", ([shared_state], {'finish_time': finish_time}))
        return shared_state.get("impl_return_value", retval)
        
    

class Tracer():
    
    
    def flush(self) -> None:
        '''"
Flush the tracer's internal buffer, sending spans to Datadog's intake endpoint
"
'''
        
        retval = None
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Tracer.flush", ([shared_state], {}))
        return shared_state.get("impl_return_value", retval)
        
    
    def set_tags(self, tags: Dict[str, str]) -> None:
        '''"
Set some tags at the tracer level. This will append those tags to each span created by
the tracer.
"
'''
        
        retval = None
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Tracer.set_tags", ([shared_state, tags], {}))
        return shared_state.get("impl_return_value", retval)
        
    
    def shutdown(self, timeout: Optional[float]) -> None:
        '''"Shutdown the tracer and flush finished traces. Avoid calling shutdown multiple times."
'''
        
        retval = None
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Tracer.shutdown", ([shared_state, timeout], {}))
        return shared_state.get("impl_return_value", retval)
        
    
    def start_span(self, name: str, child_of:Optional[Span]=None, service:Optional[str]=None, resource:Optional[str]=None, span_type:Optional[str]=None, activate:bool='False') -> Span:
        ''''Return a span that represents an operation called ``name``.

Note that the ``.trace`` method will almost always be preferred
over this method as it provides automatic span parenting. This method
should only be used if manual parenting is desired.

To start a new root span::

    span = tracer.start_span("web.request")

To create a child for a root span::

    root_span = tracer.start_span("web.request")
    span = tracer.start_span("web.decoder", child_of=root_span)

Spans from ``start_span`` are not activated by default::

    with tracer.start_span("parent") as parent:
        assert tracer.current_span() is None
        with tracer.start_span("child", child_of=parent):
            assert tracer.current_span() is None

    new_parent = tracer.start_span("new_parent", activate=True)
    assert tracer.current_span() is new_parent
'
'''
        
        retval = Span()
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Tracer.start_span", ([shared_state, name], {'child_of': child_of, 'service': service, 'resource': resource, 'span_type': span_type, 'activate': activate}))
        return shared_state.get("impl_return_value", retval)
        
    
    def current_root_span(self) -> Span:
        '''"Returns the local root span of the current execution/process.

Note - This cannot be used to access the true root span of the trace
in a distributed tracing setup if the actual root span occurred in
another execution/process.

This is useful for attaching information to the local root span
of the current execution/process, which is often also service
entry span.

For example::

    # get the local root span
    local_root_span = tracer.current_root_span()
    # set the host just once on the root span
    if local_root_span:
        local_root_span.set_tag('host', '127.0.0.1')
"
'''
        
        retval = Span()
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Tracer.current_root_span", ([shared_state], {}))
        return shared_state.get("impl_return_value", retval)
        
    
    def current_span(self) -> Span:
        ''''Return the active span in the current execution context.

Note that there may be an active span from a distributed trace which will not
be returned by this method.
'
'''
        
        retval = Span()
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Tracer.current_span", ([shared_state], {}))
        return shared_state.get("impl_return_value", retval)
        
    
    def trace(self, name: str, service:Optional[str]=None, resource:Optional[str]=None, span_type:Optional[str]=None) -> Span:
        ''''
Activate and return a new span that inherits from the current active span.

The returned span *must* be ``finish``ed or it will remain in memory
indefinitely::

    >>> span = tracer.trace("web.request")
        try:
            # do something
        finally:
            span.finish()

    >>> with tracer.trace("web.request") as span:
            # do something

Example of the automatic parenting::

    parent = tracer.trace("parent")     # has no parent span
    assert tracer.current_span() is parent

    child  = tracer.trace("child")
    assert child.parent_id == parent.span_id
    assert tracer.current_span() is child
    child.finish()

    # parent is now the active span again
    assert tracer.current_span() is parent
    parent.finish()

    assert tracer.current_span() is None

    parent2 = tracer.trace("parent2")
    assert parent2.parent_id is None
    parent2.finish()
'
'''
        
        retval = Span()
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Tracer.trace", ([shared_state, name], {'service': service, 'resource': resource, 'span_type': span_type}))
        return shared_state.get("impl_return_value", retval)
        
    
    def wrap(self, name:Optional[str]=None, service:Optional[str]=None, resource:Optional[str]=None, span_type:Optional[str]=None) -> Callable[[TypeVar('AnyCallable', bound=Callable)], TypeVar('AnyCallable', bound=Callable)]:
        ''''
A decorator used to trace an entire function. If the traced function
is a coroutine, it traces the coroutine execution when is awaited.
If a ``wrap_executor`` callable has been provided in the ``Tracer.configure()``
method, it will be called instead of the default one when the function
decorator is invoked.

>>> @tracer.wrap("my.wrapped.function", service="my.service")
    def run():
        return "run"

>>> # name will default to "execute" if unset
    @tracer.wrap()
    def execute():
        return "executed"

>>> # or use it in asyncio coroutines
    @tracer.wrap()
    async def coroutine():
        return "executed"

>>> @tracer.wrap()
    @asyncio.coroutine
    def coroutine():
        return "executed"

You can access the current span using `tracer.current_span()` to set
tags:

>>> @tracer.wrap()
    def execute():
        span = tracer.current_span()
        span.set_tag("a", "b")
'
'''
        
        def wrap_decorator(f):
            @functools.wraps(f)
            def func_wrapper(*args, **kwargs):
                return f(*args, **kwargs)

            return func_wrapper
    
        retval = wrap_decorator
        shared_state = {'api_return_value': retval, 'stub_self': self}
        shared_state['impl_return_value'] = None
        audit(_DD_HOOK_PREFIX + "Tracer.wrap", ([shared_state], {'name': name, 'service': service, 'resource': resource, 'span_type': span_type}))
        return shared_state.get("impl_return_value", retval)
        
    

tracer = Tracer()

    

span = _Stub()

setattr(span, "Span", Span)
    
    
