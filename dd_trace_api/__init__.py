
# This file was generated by generate.py. Do not modify directly.
import functools
from sys import audit
from types import TracebackType  # noqa:F401
from typing import Optional, Any, Callable, Dict, List, Union, Text, Tuple, TypeVar, Type  # noqa:F401
import importlib.metadata
__version__ = importlib.metadata.version('dd_trace_api')

_DD_HOOK_PREFIX = "dd.hooks."


class _Stub:
    pass
    

class Span():
    
    
    def __enter__(self) -> 'Span':
        
        retval = self
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Span.__enter__", ([shared_state], {}))
        retval = shared_state.get("impl_return_value", retval)
        return retval
        
    
    def __exit__(self, exc_type: Type[BaseException], exc_val: BaseException, exc_tb: Optional[TracebackType]) -> None:
        
        retval = None
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Span.__exit__", ([shared_state, exc_type, exc_val, exc_tb], {}))
        retval = shared_state.get("impl_return_value", retval)
        return retval
        
    
    def set_exc_info(self, exc_type: Type[BaseException], exc_val: BaseException, exc_tb: Optional[TracebackType]) -> None:
        
        retval = None
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Span.set_exc_info", ([shared_state, exc_type, exc_val, exc_tb], {}))
        retval = shared_state.get("impl_return_value", retval)
        return retval
        
    
    def set_traceback(self, limit:Optional[int]=None) -> None:
        
        retval = None
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Span.set_traceback", ([shared_state], {'limit': limit}))
        retval = shared_state.get("impl_return_value", retval)
        return retval
        
    
    def set_tags(self, tags: Dict[Union[Text, bytes], Any]) -> None:
        
        retval = None
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Span.set_tags", ([shared_state, tags], {}))
        retval = shared_state.get("impl_return_value", retval)
        return retval
        
    
    def finish_with_ancestors(self) -> None:
        
        retval = None
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Span.finish_with_ancestors", ([shared_state], {}))
        retval = shared_state.get("impl_return_value", retval)
        return retval
        
    
    def finish(self, finish_time:Optional[float]=None) -> None:
        
        retval = None
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Span.finish", ([shared_state], {'finish_time': finish_time}))
        retval = shared_state.get("impl_return_value", retval)
        return retval
        
    

class Tracer():
    
    
    def flush(self) -> None:
        
        retval = None
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Tracer.flush", ([shared_state], {}))
        retval = shared_state.get("impl_return_value", retval)
        return retval
        
    
    def set_tags(self, tags: Dict[str, str]) -> None:
        
        retval = None
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Tracer.set_tags", ([shared_state, tags], {}))
        retval = shared_state.get("impl_return_value", retval)
        return retval
        
    
    def shutdown(self, timeout: Optional[float]) -> None:
        
        retval = None
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Tracer.shutdown", ([shared_state, timeout], {}))
        retval = shared_state.get("impl_return_value", retval)
        return retval
        
    
    def start_span(self, name: str, child_of:Optional[Span]=None, service:Optional[str]=None, resource:Optional[str]=None, span_type:Optional[str]=None, activate:bool='False') -> Span:
        
        retval = Span()
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Tracer.start_span", ([shared_state, name], {'child_of': child_of, 'service': service, 'resource': resource, 'span_type': span_type, 'activate': activate}))
        retval = shared_state.get("impl_return_value", retval)
        return retval
        
    
    def current_root_span(self) -> Span:
        
        retval = Span()
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Tracer.current_root_span", ([shared_state], {}))
        retval = shared_state.get("impl_return_value", retval)
        return retval
        
    
    def current_span(self) -> Span:
        
        retval = Span()
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Tracer.current_span", ([shared_state], {}))
        retval = shared_state.get("impl_return_value", retval)
        return retval
        
    
    def trace(self, name: str, service:Optional[str]=None, resource:Optional[str]=None, span_type:Optional[str]=None) -> Span:
        
        retval = Span()
        shared_state = {'api_return_value': retval, 'stub_self': self}
        
        audit(_DD_HOOK_PREFIX + "Tracer.trace", ([shared_state, name], {'service': service, 'resource': resource, 'span_type': span_type}))
        retval = shared_state.get("impl_return_value", retval)
        return retval
        
    
    def wrap(self, name:Optional[str]=None, service:Optional[str]=None, resource:Optional[str]=None, span_type:Optional[str]=None) -> Callable[[TypeVar('AnyCallable', bound=Callable)], TypeVar('AnyCallable', bound=Callable)]:
        
        def wrap_decorator(f):
            @functools.wraps(f)
            def func_wrapper(*args, **kwargs):
                return f(*args, **kwargs)

            return func_wrapper
    
        retval = wrap_decorator
        shared_state = {'api_return_value': retval, 'stub_self': self}
        shared_state['impl_return_value'] = None
        audit(_DD_HOOK_PREFIX + "Tracer.wrap", ([shared_state], {'name': name, 'service': service, 'resource': resource, 'span_type': span_type}))
        retval = shared_state.get("impl_return_value", retval)
        return retval
        
    

tracer = Tracer()

    

span = _Stub()

setattr(span, "Span", Span)
    
    
